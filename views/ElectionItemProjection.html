<div class="q-election-item">
  <div class="q-election-item-text">
    <div class="s-font-text-s q-election-item-text-party">{item.name}</div>
    {#if hasErrorMargin}
      <div class="s-font-note q-election-item-text-current">{item.projection.lower}â€“{item.projection.upper}%</div>
    {:elseif item.projection && item.projection.bestGuess}
      <div class="s-font-note q-election-item-text-current">{item.projection.bestGuess}%</div>
    {/if}
  </div>
  <div class="q-election-item-projection-bar">
    <div class="q-election-item-bar-color q-election-item-bar-color--fullwidth q-election-item-bar-color--slim s-color-gray-3"></div>
    <div class="q-election-item-bar-color q-election-item-bar-color--slim {item.colorClass}" style="width: {coloredSlimBarWidthPercentage}%; {item.colorStyle}"></div>
    {#if hasErrorMargin}
      <div class="q-election-item-bar-color q-election-item-bar-color--projection {item.colorClass}" style="left: {projectionLeftPercentage}%; width: {barWidthPercentage}%; {item.colorStyle}"></div>
    {/if}
    <div class="q-election-item-dot-color {item.colorClass}" style="left: {dotPositionLeftPercentage}%; {item.colorStyle}"></div>
  </div>
</div>

<script>
  export default {
    computed: {
      barWidthPercentage: ({ item, maxProjection }) => {
        if (maxProjection === undefined || !item.projection || item.projection.lower === undefined || !item.projection.upper === undefined) {
          return 0;
        }
        return (item.projection.upper / maxProjection * 100) - (item.projection.lower / maxProjection * 100);
      },
      coloredSlimBarWidthPercentage: ({ item, maxProjection, hasErrorMargin}) => {
        if (hasErrorMargin) {
          if (maxProjection === undefined || !item.projection || item.projection.lower === undefined) {
            return 0;
          }
          return (item.projection.lower / maxProjection * 100);
        } else {
          if (maxProjection === undefined || !item.projection || item.projection.bestGuess === undefined) {
            return 0;
          }
          return (item.projection.bestGuess / maxProjection * 100);
        }
      },
      projectionLeftPercentage: ({ item, maxProjection }) => {
        if (maxProjection === undefined || !item.projection || item.projection.lower === undefined) {
          return 0;
        }
        return (item.projection.lower / maxProjection * 100);
      },
      dotPositionLeftPercentage: ({ item, maxProjection }) => {
        if (maxProjection === undefined || !item.projection || item.projection.bestGuess === undefined) {
          return 0;
        }
        return (item.projection.bestGuess / maxProjection * 100);
      },
      hasErrorMargin: ({ item }) => {
        return item.projection && item.projection.lower !== undefined && item.projection.upper !== undefined;
      }
    }
  }
</script>