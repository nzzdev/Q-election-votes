<div class="q-item-container">
  <Header title='{{item.title}}' titleClassAttribute='{{titleClassAttribute}}' subtitle='{{item.subtitle}}' />
  <div class="q-election-parties {{thresholdOffset}}">
    <Threshold threshold='{{threshold}}' maxResult='{{maxResult}}' />
    {{#each partyItems as party}}
      <ElectionItem item='{{party}}' maxResult='{{maxResult}}' />
    {{/each}}
  </div>
  {{#if otherPartiesItem}}
    <div class="q-election-others">
      <ElectionItem item='{{otherPartiesItem}}' maxResult='{{maxResult}}' />
    </div>
  {{/if}}
  <Footer sources='{{item.sources}}' notes='{{item.notes}}' updatedDate='{{item.updatedDate}}' maxResult='{{maxResult}}'/>
</div>

<script>
  import Header from './Header.html';
  import Threshold from './Threshold.html';
  import ElectionItem from './ElectionItem.html';
  import Footer from './Footer.html';

  export default {
    computed: {
      parties: (item) => {
        return item.parties;
      },
      titleClassAttribute: (toolRuntimeConfig) => {
        if (toolRuntimeConfig.displayOptions && toolRuntimeConfig.displayOptions.hideTitle) {
          return 'q-election-title--hidden';
        }
        return '';
      },
      sortedParties: (parties) => {
        if (parties !== undefined) {
          return parties.sort(function(partyA, partyB) {
            if (partyA.percentage === undefined) {
              partyA.percentage = 0;
            }
            if (partyB.percentage === undefined) {
              partyB.percentage = 0;
            }
            return partyB.percentage - partyA.percentage;
          })
        } else {
          return [];
        }
      },
      maxResult: (sortedParties) => {
        let maxResult = 0;
        // if there are already any votes the first party 
        // of sorted list of party has max percentage
        if (sortedParties[0] && sortedParties[0].percentage) {
          maxResult = sortedParties[0].percentage;
        }
        return maxResult;
      },
      enhancedParties: (sortedParties, maxResult) => {
        // return the number of decimal places for each percentage number
        function getDecimalsInput(percentages) {
          return percentages.map(percentageValue => {
            if (percentageValue !== undefined) {
              let percentageString = percentageValue.toString();
              let parts = percentageString.split('.');
              if (parts[1] !== undefined) {
                return parts[1].length;
              }
            }
            return 0;
          })
        }
        
        // define the number of decimal places which shall be displayed, max = 2
        function setDecimalsOutput(decimals) {
          let bigDecimals = decimals.filter(value => value > 1);
          if (bigDecimals !== undefined && bigDecimals.length > 0) {
            return 2;
          }
          let oneDecimal = decimals.filter(value => value === 1);
          if (oneDecimal !== undefined && oneDecimal.length > 0) {
            return 1;
          }
          return 0;
        }

        // create an array for vote values (currentPercentages) and trend values (trendPercentages)
        let currentPercentages = sortedParties.map(party => party.percentage);
        let trendPercentages = sortedParties.map(party => parseFloat((party.percentage - party.previous).toFixed(2)));
        
        // get number of decimal places for vote values and trend values
        let currentDecimals = getDecimalsInput(currentPercentages);
        let trendDecimals = getDecimalsInput(trendPercentages);
        
        // set number of decimals which should be displayed for vote values and trend values separately
        let currentNumberDecimals = setDecimalsOutput(currentDecimals);
        let trendNumberDecimals = setDecimalsOutput(trendDecimals);

        sortedParties.forEach(party => {
          // define width of each party's bar
          let width = '1px';
          if (maxResult > 0 && party.percentage && party.percentage > 0) {
            let widthPercentage = party.percentage * 100 / maxResult;
            width = widthPercentage + '%';
          }
          party.width = width;
          
          // define color of each party's bar either via class attribute or color code
          let colorStyle = '';
          let colorClass = '';
          if (party.color) {
            if (party.color.classAttribute) {
              colorClass = party.color.classAttribute;
            } else {
              colorStyle = 'background-color: ' + party.color.colorCode + ';';
            }
          }
          party.colorClass = colorClass;
          party.colorStyle = colorStyle;
          
          // calculate trend out of previous and current result and use it 
          // to calculate rotation degree of trend arrow
          if (party.percentage !== undefined) {
            if (party.previous !== undefined) {
              party.trend = party.percentage - party.previous;
            } else {
              party.trend = party.percentage;
            }
            let trendDegree = (Math.min(Math.abs(party.trend),5) * 90) / 5;
            if (party.trend > 0) {
              trendDegree = -trendDegree;
            }
            party.trendDegree = trendDegree;
            party.trendWidth = 24 + (trendNumberDecimals * 8) + 'px';

            party.percentage = party.percentage.toFixed(currentNumberDecimals);
            party.trend = party.trend.toFixed(trendNumberDecimals);

          }
        })
        
        // process the group of other parties differently - not part of the threshold
        let othersIndex = sortedParties.findIndex(party => {
          let othersPattern = /((.*(A|a)ndere.*)|(.*(S|s)onstig.*))/; 
          return othersPattern.test(party.name);
        })
        if (othersIndex >= 0) {
          let others = sortedParties.splice(othersIndex, 1);
          return {
            parties: sortedParties,
            others: others[0]
          }
        } else {
          return {
            parties: sortedParties
          }
        }
      },
      partyItems: (enhancedParties) => {
        return enhancedParties.parties
      },
      otherPartiesItem : (enhancedParties) => {
        return enhancedParties.others;
      },
      threshold: (item) => {
        return item.threshold;
      },
      thresholdOffset: (threshold, maxResult) => {
        if (threshold !== undefined && threshold > 0 && maxResult > 0) {
          return 'q-election-threshold-offset';
        }
        else '';
      }
    },

    components: {
      Header,
      Threshold,
      ElectionItem,
      Footer
    }
  };
</script>
