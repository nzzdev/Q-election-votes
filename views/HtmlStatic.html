<div class="q-election" style="opacity: 0;">
  <Header title='{{item.title}}' hideTitle='{{hideTitle}}' subtitle='{{item.subtitle}}' />
  <div class="q-election-parties {{thresholdOffset}}">
    <Threshold threshold='{{threshold}}' base='{{base}}' />
    {{#each partyItems as party}}
      <ElectionItem item='{{party}}' hasTrendSpace='{{hasTrendSpace}}'/>
    {{/each}}
  </div>
  {{#if otherPartiesItem}}
    <div class="q-election-others">
      <ElectionItem item='{{otherPartiesItem}}' hasTrendSpace='{{hasTrendSpace}}'/>
    </div>
  {{/if}}
  <Footer sources='{{item.sources}}' notes='{{item.notes}}' updatedDate='{{item.updatedDate}}' hideUpdatedDate='{{hideUpdatedDate}}'/>
</div>

<script>
  import Header from './Header.html';
  import Threshold from './Threshold.html';
  import ElectionItem from './ElectionItem.html';
  import Footer from './Footer.html';

  export default {
    computed: {
      parties: (item) => {
        return item.parties;
      },
      hideTitle: (toolRuntimeConfig) => {
        return toolRuntimeConfig.displayOptions && toolRuntimeConfig.displayOptions.hideTitle;
      },
      hasCurrentResults: (parties) => {
        let currentResults = parties.filter(party => {
          return party.percentage !== undefined;
        });
        return currentResults.length > 0;
      },
      sortedParties: (parties) => {
        if (parties !== undefined) {
          return parties.sort(function(partyA, partyB) {
            if ((partyA.percentage === undefined && partyB.percentage === undefined) || (partyA.percentage === partyB.percentage)) {
              return 0;
            }
            if ((partyA.percentage === undefined && partyB.percentage !== undefined) || (partyA.percentage < partyB.percentage)) {
              return 1;
            }
            return -1;
          })
        } else {
          return [];
        }
      },
      hasTrendSpace: (parties) => {
        const partiesWithPreviousResult = parties.filter(party => {
          return party.previous !== undefined;
        });
        return partiesWithPreviousResult.length > 0;
      },
      maxResult: (sortedParties) => {
        let maxResult = 0;
        // if there are already any votes the first party 
        // of sorted list of party has max percentage
        if (sortedParties[0] && sortedParties[0].percentage) {
          maxResult = sortedParties[0].percentage;
        }
        return maxResult;
      },
      base: (maxResult, hasCurrentResults) => {
        let base = maxResult;
        if (!hasCurrentResults) {
          base = 100;
        }
        return base;
      },
      enhancedParties: (sortedParties, maxResult) => {
        // return the number of decimal places for each percentage number
        function getDecimalsInput(percentages) {
          return percentages.map(percentageValue => {
            if (percentageValue !== undefined) {
              let percentageString = percentageValue.toString();
              let parts = percentageString.split('.');
              if (parts[1] !== undefined) {
                return parts[1].length;
              }
            }
            return 0;
          })
        }
        
        // define the number of decimal places which shall be displayed, max = 2
        function setDecimalsOutput(decimals) {
          let bigDecimals = decimals.filter(value => value > 1);
          if (bigDecimals !== undefined && bigDecimals.length > 0) {
            return 2;
          }
          let oneDecimal = decimals.filter(value => value === 1);
          if (oneDecimal !== undefined && oneDecimal.length > 0) {
            return 1;
          }
          return 0;
        }

        // create an array for vote values (currentPercentages) and trend values (trendPercentages)
        let currentPercentages = sortedParties.map(party => party.percentage);
        let trendPercentages = sortedParties.map(party => parseFloat((party.percentage - party.previous).toFixed(2)));
        
        // get number of decimal places for vote values and trend values
        let currentDecimals = getDecimalsInput(currentPercentages);
        let trendDecimals = getDecimalsInput(trendPercentages);
        
        // set number of decimals which should be displayed for vote values and trend values separately
        let currentNumberDecimals = setDecimalsOutput(currentDecimals);
        let trendNumberDecimals = setDecimalsOutput(trendDecimals);

        // if no color is defined for parties we assign a default color, which is one of the following
        // gray levels - other levels are either used or too light
        const defaultGrayLevels = [4, 5, 6, 7, 8, 9];

        sortedParties.forEach((party, index) => {
          // define width of each party's bar
          let width = '1px';
          if (maxResult > 0 && party.percentage && party.percentage > 0) {
            let widthPercentage = party.percentage * 100 / maxResult;
            width = widthPercentage + '%';
          }
          party.width = width;
          
          // define color of each party's bar either via class attribute or color code
          let colorStyle = '';
          let colorClass = '';
          if (party.color) {
            if (party.color.classAttribute) {
              colorClass = party.color.classAttribute;
            } else if (party.color.colorCode) {
              colorStyle = 'background-color: ' + party.color.colorCode + ';';
            }
          }

          // if no color is defined assign a default color
          if (!colorClass && !colorStyle) {
            colorClass = `s-color-gray-${defaultGrayLevels[index % defaultGrayLevels.length]}`;
          }

          party.colorClass = colorClass;
          party.colorStyle = colorStyle;
          
          // calculate trend out of previous and current result and use it 
          // to calculate rotation degree of trend arrow
          if (party.percentage !== undefined) {
            party.percentage = party.percentage.toFixed(currentNumberDecimals);

            if (party.previous !== undefined) {
              party.trend = party.percentage - party.previous;
              
              let trendDegree = (Math.min(Math.abs(party.trend),5) * 90) / 5;
              if (party.trend > 0) {
                trendDegree = -trendDegree;
              }
              party.trendDegree = trendDegree;
              party.trend = party.trend.toFixed(trendNumberDecimals);
            }
          }
          party.trendWidth = 24 + (trendNumberDecimals * 8) + 'px';
        })
        
        // process the group of other parties differently - not part of the threshold
        let othersIndex = sortedParties.findIndex(party => {
          let othersPattern = /((.*(A|a)ndere.*)|(.*(S|s)onstig.*))/; 
          return othersPattern.test(party.name);
        })
        if (othersIndex >= 0) {
          let others = sortedParties.splice(othersIndex, 1);
          return {
            parties: sortedParties,
            others: others[0]
          }
        } else {
          return {
            parties: sortedParties
          }
        }
      },
      partyItems: (enhancedParties) => {
        return enhancedParties.parties
      },
      otherPartiesItem : (enhancedParties) => {
        return enhancedParties.others;
      },
      threshold: (item) => {
        return item.threshold;
      },
      thresholdOffset: (threshold, base) => {
        if (threshold !== undefined && threshold > 0 && base > 0) {
          return 'q-election-threshold-offset';
        }
        else '';
      },
      hideUpdatedDate: (item) => {
        return item.options && item.options.hideUpdatedDate;
      }
    },

    components: {
      Header,
      Threshold,
      ElectionItem,
      Footer
    }
  };
</script>
