<div class="q-election" style="opacity: 0;">
  <Header title='{item.title}' hideTitle='{hideTitle}' subtitle='{item.subtitle}' withErrorMargin='{withErrorMargin}' hasErrorMargin='{hasErrorMargin}'/>
  <div class="q-election-parties {thresholdOffsetClasses}">
    <Threshold threshold='{threshold}' base='{base}' withErrorMargin='{withErrorMargin}'/>
    {#each partyItems as party}
      {#if withErrorMargin}
        <ElectionItemErrorMargin item='{party}' maxErrorMarginValue='{maxErrorMarginValue}'/>
      {:else}
        <ElectionItem item='{party}' hasTrendSpace='{hasTrendSpace}'/>
      {/if}
    {/each}
  </div>
  {#if otherPartiesItem}
    <div class="q-election-others">
      {#if withErrorMargin}
        <ElectionItemErrorMargin item='{otherPartiesItem}' maxErrorMarginValue='{maxErrorMarginValue}'/>
      {:else}
        <ElectionItem item='{otherPartiesItem}' hasTrendSpace='{hasTrendSpace}'/>
      {/if}
    </div>
  {/if}
  <Footer sources='{item.sources}' notes='{item.notes}' updatedDate='{item.updatedDate}' hideUpdatedDate='{hideUpdatedDate}'/>
</div>

<script>
  import Header from './Header.html';
  import Threshold from './Threshold.html';
  import ElectionItem from './ElectionItem.html';
  import ElectionItemErrorMargin from './ElectionItemErrorMargin.html';
  import Footer from './Footer.html';

  export default {
    computed: {
      parties: ({ item }) => {
        return item.parties;
      },
      hideTitle: ({ toolRuntimeConfig }) => {
        return toolRuntimeConfig.displayOptions && toolRuntimeConfig.displayOptions.hideTitle;
      },
      hasCurrentResults: ({ parties }) => {
        let currentResults = parties.filter(party => {
          return party.percentage !== undefined;
        });
        return currentResults.length > 0;
      },
      hasCurrenterrorMargins: ({ parties }) => {
        let currentResults = parties.filter(party => {
          return party.errorMargin !== undefined && party.errorMargin.bestGuess !== undefined;
        });
        return currentResults.length > 0;
      },
      sortedParties: ({ parties, item }) => {
        if (parties !== undefined) {
          if (item.withErrorMargin) {
            return parties.sort(function(partyA, partyB) {
              // if any of the 2 parties has no errorMargin, we sort by this first
              if (!partyA.errorMargin && !partyB.errorMargin) {
                return 0;
              }
              if (!partyA.errorMargin && partyB.errorMargin) {
                return 1;
              }
              if (partyA.errorMargin && !partyB.errorMargin) {
                return -1;
              }

              // then move on to check for any errorMargin data and sort accordingly
              if ((partyA.errorMargin.upper === undefined && partyB.errorMargin.upper === undefined) || (partyA.errorMargin.upper === partyB.errorMargin.upper)) {
                return 0;
              }
              if ((partyA.errorMargin.upper === undefined && partyB.errorMargin.upper !== undefined) || (partyA.errorMargin.upper < partyB.errorMargin.upper)) {
                return 1;
              }
              return -1;
            });
          }
          return parties.sort(function(partyA, partyB) {
            if ((partyA.percentage === undefined && partyB.percentage === undefined) || (partyA.percentage === partyB.percentage)) {
              return 0;
            }
            if ((partyA.percentage === undefined && partyB.percentage !== undefined) || (partyA.percentage < partyB.percentage)) {
              return 1;
            }
            return -1;
          })
        } else {
          return [];
        }
      },
      hasTrendSpace: ({ parties }) => {
        const partiesWithPreviousResult = parties.filter(party => {
          return party.previous !== undefined;
        });
        return partiesWithPreviousResult.length > 0;
      },
      maxResult: ({ sortedParties, item }) => {
        let maxResult = 0;
        // if there are already any votes the first party 
        // of sorted list of party has max percentage
        if (sortedParties[0] && sortedParties[0].percentage) {
          maxResult = sortedParties[0].percentage;
        }
        if (item.threshold > maxResult) {
          return item.threshold;
        }
        return maxResult;
      },
      maxErrorMarginValue: ({ sortedParties, item }) => {
        let maxErrorMarginValue = undefined;;
        // if there are already any errorMargins the first party 
        // of sorted list of party has max errorMargin upper bound
        if (sortedParties[0] && sortedParties[0].errorMargin && sortedParties[0].errorMargin.upper) {
          maxErrorMarginValue = sortedParties[0].errorMargin.upper;
        }
        if (item.threshold > maxErrorMarginValue) {
          return item.threshold;
        }
        return maxErrorMarginValue;
      },
      base: ({ maxResult, maxErrorMarginValue, hasCurrentResults, hasCurrenterrorMargins }) => {
        let base = Math.max(maxResult || 0, maxErrorMarginValue || 0);
        if (!hasCurrentResults && !hasCurrenterrorMargins) {
          base = 100;
        }
        return base;
      },
      enhancedParties: ({ sortedParties, maxResult }) => {
        // return the number of decimal places for each percentage number
        function getDecimalsInput(percentages) {
          return percentages.map(percentageValue => {
            if (percentageValue !== undefined) {
              let percentageString = percentageValue.toString();
              let parts = percentageString.split('.');
              if (parts[1] !== undefined) {
                return parts[1].length;
              }
            }
            return 0;
          })
        }
        
        // define the number of decimal places which shall be displayed, max = 2
        function setDecimalsOutput(decimals) {
          let bigDecimals = decimals.filter(value => value > 1);
          if (bigDecimals !== undefined && bigDecimals.length > 0) {
            return 2;
          }
          let oneDecimal = decimals.filter(value => value === 1);
          if (oneDecimal !== undefined && oneDecimal.length > 0) {
            return 1;
          }
          return 0;
        }

        // create an array for vote values (currentPercentages) and trend values (trendPercentages)
        let currentPercentages = sortedParties.map(party => party.percentage);
        let trendPercentages = sortedParties.map(party => parseFloat((party.percentage - party.previous).toFixed(2)));
        
        // get number of decimal places for vote values and trend values
        let currentDecimals = getDecimalsInput(currentPercentages);
        let trendDecimals = getDecimalsInput(trendPercentages);
        
        // set number of decimals which should be displayed for vote values and trend values separately
        let currentNumberDecimals = setDecimalsOutput(currentDecimals);
        let trendNumberDecimals = setDecimalsOutput(trendDecimals);

        // if no color is defined for parties we assign a default color, which is one of the following
        // gray levels - other levels are either used or too light
        const defaultGrayLevels = [4, 5, 6, 7, 8, 9];

        sortedParties.forEach((party, index) => {
          // define width of each party's bar
          let width = '1px';
          if (maxResult > 0 && party.percentage && party.percentage > 0) {
            let widthPercentage = party.percentage * 100 / maxResult;
            width = widthPercentage + '%';
          }
          party.width = width;
          
          // define color of each party's bar either via class attribute or color code
          let colorStyle = '';
          let colorClass = '';
          if (party.color) {
            if (party.color.classAttribute) {
              colorClass = party.color.classAttribute;
            } else if (party.color.colorCode) {
              colorStyle = 'background-color: ' + party.color.colorCode + ';';
            }
          }

          // if no color is defined assign a default color
          if (!colorClass && !colorStyle) {
            colorClass = `s-color-gray-${defaultGrayLevels[index % defaultGrayLevels.length]}`;
          }

          party.colorClass = colorClass;
          party.colorStyle = colorStyle;
          
          // calculate trend out of previous and current result and use it 
          // to calculate rotation degree of trend arrow
          if (party.percentage !== undefined) {
            party.percentage = party.percentage.toFixed(currentNumberDecimals);

            if (party.previous !== undefined) {
              party.trend = party.percentage - party.previous;
              
              let trendDegree = (Math.min(Math.abs(party.trend),5) * 90) / 5;
              if (party.trend > 0) {
                trendDegree = -trendDegree;
              }
              party.trendDegree = trendDegree;
              party.trend = party.trend.toFixed(trendNumberDecimals);
            }
          }
          party.trendWidth = 24 + (trendNumberDecimals * 8) + 'px';
        })
        
        // process the group of other parties differently - not part of the threshold
        let othersIndex = sortedParties.findIndex(party => {
          let othersPattern = /((.*(A|a)ndere.*)|(.*(S|s)onstig.*))/; 
          return othersPattern.test(party.name);
        })
        if (othersIndex >= 0) {
          let others = sortedParties.splice(othersIndex, 1);
          return {
            parties: sortedParties,
            others: others[0]
          }
        } else {
          return {
            parties: sortedParties
          }
        }
      },
      partyItems: ({ enhancedParties }) => {
        return enhancedParties.parties
      },
      otherPartiesItem : ({ enhancedParties }) => {
        return enhancedParties.others;
      },
      threshold: ({ item }) => {
        return item.threshold;
      },
      withErrorMargin: ({ item }) => {
        return item.withErrorMargin;
      },
      hasErrorMargin: ({ item }) => {
        return item.parties.some(party => {
          return party.errorMargin && party.errorMargin.lower !== undefined && party.errorMargin.upper !== undefined
        });
      },
      thresholdOffsetClasses: ({ threshold, base, withErrorMargin }) => {
        if (threshold !== undefined && threshold > 0 && base > 0) {
          let classes = 'q-election-threshold-offset';
          if (withErrorMargin) {
            classes += ' q-election-threshold-offset--error-margin';
          }
          return classes;
        }
        return '';
      },
      hideUpdatedDate: ({ item }) => {
        return item.options && item.options.hideUpdatedDate;
      }
    },

    components: {
      Header,
      Threshold,
      ElectionItem,
      ElectionItemErrorMargin,
      Footer
    }
  };
</script>
